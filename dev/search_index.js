var documenterSearchIndex = {"docs":
[{"location":"opf/socwr/#SOC-OPF","page":"SOC-OPF","title":"SOC-OPF","text":"","category":"section"},{"location":"opf/socwr/","page":"SOC-OPF","title":"SOC-OPF","text":"The SOC-OPF model considered in PGLearn is presented below.","category":"page"},{"location":"opf/socwr/#Definitions","page":"SOC-OPF","title":"Definitions","text":"","category":"section"},{"location":"opf/socwr/","page":"SOC-OPF","title":"SOC-OPF","text":"The second order cone and rotated second-order cone of order n are defined as","category":"page"},{"location":"opf/socwr/","page":"SOC-OPF","title":"SOC-OPF","text":"beginalign*\nmathcalQ^n = left\n    x in mathbbR^n   \n middle \n    x_1 geq sqrtx_2^2 +  + x_n^2\nright\nmathcalQ_r^n = left\n    x in mathbbR^n   \n middle \n    2 x_1 x_2 geq x_3^2 +  + x_n^2\n    x_1 x_2 geq 0\nright\nendalign*","category":"page"},{"location":"opf/socwr/#Mathematical-formulation","page":"SOC-OPF","title":"Mathematical formulation","text":"","category":"section"},{"location":"opf/socwr/","page":"SOC-OPF","title":"SOC-OPF","text":"The SOC-OPF formulation in PGLearn is the Jabr relaxation of AC-OPF. The formulation is obtained through the change of variable","category":"page"},{"location":"opf/socwr/","page":"SOC-OPF","title":"SOC-OPF","text":"beginalign*\nwm_i = VM_i^2 \n     forall i in NODES \nwr_e = VM_i VM_j cos (theta_i - theta_j) \n     forall e = (i j) in EDGES \nwi_e = VM_i VM_j sin (theta_i - theta_j) \n     forall e = (i j) in EDGES\nendalign*","category":"page"},{"location":"opf/socwr/","page":"SOC-OPF","title":"SOC-OPF","text":"Note that wr_e and wi_e correspond to  the real and imaginary parts of the complex voltage product V_iV_j^*, respectively. This transformation implies the non-convex equality","category":"page"},{"location":"opf/socwr/","page":"SOC-OPF","title":"SOC-OPF","text":"(wr)^2 + (wi)^2 = VM_i^2 times VM_j^2 = wm_i times wm_j","category":"page"},{"location":"opf/socwr/","page":"SOC-OPF","title":"SOC-OPF","text":"The Jabr relaxation is obtained by relaxing this into the convex constraint","category":"page"},{"location":"opf/socwr/","page":"SOC-OPF","title":"SOC-OPF","text":"(wr)^2 + (wi)^2 leq wm_i times wm_j","category":"page"},{"location":"opf/socwr/","page":"SOC-OPF","title":"SOC-OPF","text":"The resulting SOC-OPF model is presented below.","category":"page"},{"location":"opf/socwr/","page":"SOC-OPF","title":"SOC-OPF","text":"beginalign\n    min quad \n     labeleqSOCOPFobjective\n        sum_i in NODES sum_j in GENERATORS_i c_j PG_j + c_0\n    textst quad\n     labeleqSOCOPFkcl_p\n        sum_g in GENERATORS_i PG_g\n        - sum_e in EDGES^+_i PF_e\n        - sum_e in EDGES^-_i PT_e\n        - GS_i wm_i\n        = sum_jinLOADS_i PD_j\n         forall i  in NODES\n          lambda^p\n        \n     labeleqSOCOPFkcl_q\n        sum_g in GENERATORS_i QG_g\n        - sum_e in EDGES^+_i QF_e\n        - sum_e in EDGES^-_i QT_e\n        + BS_i wm_i\n        = sum_jinLOADS_i QD_j\n         forall i  in NODES\n          lambda^q\n        \n     Ohms law\n     labeleqSOCOPFohm_pf\n        gff_e wm_i\n        + gft_e wr_e\n        + bft_e wi_e\n        - PF_e = 0\n         forall e = (ij)  in EDGES\n          lambda^pf\n        \n     labeleqSOCOPFohm_qf\n        -bff_e wm_i\n        - bft_e wr_e\n        + gft_e wi_e\n        - QF_e = 0\n         forall e = (ij)  in EDGES\n          lambda^qf\n        \n     labeleqSOCOPFohm_pt\n        gtt_e wm_j\n        + gtf_e wr_e\n        - btf_e wi_e\n        - PT_e = 0\n         forall e = (ij)  in EDGES\n          lambda^pt\n        \n     labeleqSOCOPFohm_qt\n        -btt_e wm_j\n        - btf_e wr_e\n        - gtf_e wi_e\n        - QT_e = 0\n         forall e = (ij)  in EDGES\n          lambda^qt\n        \n     Jabr constraints\n     labeleqSOCOPFjabr\n        left(\n            fracwm_isqrt2\n            fracwm_jsqrt2\n            wr_e\n            wi_e\n        right)\n        in mathcalQ_r^4\n         forall e = (ij)  in EDGES\n          omega\n        \n     Thermal limits\n     labeleqSOCOPFsm_f\n        (overlineS_e PF_e QF_e)\n        in mathcalQ^3\n         forall e  in EDGES\n          nu^f\n        \n     labeleqSOCOPFsm_t\n        (overlineS_e PT_e QT_e)\n        in mathcalQ^3\n         forall e  in EDGES\n          nu^t\n        \n     Voltage angle deviation\n     labeleqSOCOPFva_diff\n        tan(dvamin_e) wr_e leq wi_e leq tan(dvamax_e) wr_e\n         forall e  in EDGES\n          mu^Delta theta\n        \n     Variable bounds\n     labeleqSOCOPFpg_bounds\n        pgmin_i leq PG_i leq pgmax_i \n         forall i  in GENERATORS\n          mu^pg\n        \n     labeleqSOCOPFqg_bounds\n        qgmin_i leq QG_i leq qgmax_i\n         forall i  in GENERATORS\n          mu^qg\n        \n     labeleqSOCOPFwm_bounds\n        vmmin_i^2 leq wm_i leq vmmax_i^2 \n         forall i  in NODES\n          mu^w\n         \n     labeleqSOCOPFwr_bounds\n        wrmin_e leq wr_e leq wrmax_e\n         forall e  in EDGES\n          mu^wr\n        \n     labeleqSOCOPFwi_bounds\n        wimin_e leq wi_e leq wimax_e\n         forall e  in EDGES\n          mu^wi\n        \n     labeleqSOCOPFpf_bounds\n        -overlineS_e leq PF_e leq overlineS_e\n         forall e  in EDGES\n          mu^pf\n        \n     labeleqSOCOPFqf_bounds\n        -overlineS_e leq QF_e leq overlineS_e\n         forall e  in EDGES\n          mu^qf\n        \n     labeleqSOCOPFpt_bounds\n        -overlineS_e leq PT_e leq overlineS_e\n         forall e  in EDGES\n           mu^pt\n        \n     labeleqSOCOPFqt_bounds\n        -overlineS_e leq QT_e leq overlineS_e\n         forall e  in EDGES\n          mu^qt\nendalign","category":"page"},{"location":"opf/socwr/#Variables","page":"SOC-OPF","title":"Variables","text":"","category":"section"},{"location":"opf/socwr/","page":"SOC-OPF","title":"SOC-OPF","text":"wm in mathbbR^N: squared nodal voltage magnitude\nPG in mathbbR^G: active power dispatch\nQG in mathbbR^G: reactive power dispatch\nwr in mathbbR^E: real part of voltage product\nwi in mathbbR^E: imaginary part of voltage product\nPF in mathbbR^E: active power flow \"from\"\nQF in mathbbR^E: reactive power flow \"from\"\nPT in mathbbR^E: active power flow \"to\"\nQT in mathbbR^E: reactive power flow \"to\"","category":"page"},{"location":"opf/socwr/#Objective","page":"SOC-OPF","title":"Objective","text":"","category":"section"},{"location":"opf/socwr/","page":"SOC-OPF","title":"SOC-OPF","text":"The objective function eqrefeqSOCOPFobjective minimizes the cost of active power generation.","category":"page"},{"location":"opf/socwr/","page":"SOC-OPF","title":"SOC-OPF","text":"todo: Todo\nPGLearn currently supports only linear cost functions. Support for quadratic functions is planned for a later stage; please open an issue if  you would like to request this feature.","category":"page"},{"location":"opf/socwr/#Constraints","page":"SOC-OPF","title":"Constraints","text":"","category":"section"},{"location":"opf/socwr/","page":"SOC-OPF","title":"SOC-OPF","text":"eqrefeqSOCOPFkcl_p-eqrefeqSOCOPFkcl_q:   Kirchhoff's current law for active and reactive power\neqrefeqSOCOPFohm_pf-eqrefeqSOCOPFohm_qt:   Ohm's law for active/reactive power flows in from and to directions\neqrefeqSOCOPFjabr: Jabr constraint\neqrefeqSOCOPFsm_f-eqrefeqSOCOPFsm_t: thermal limits\neqrefeqSOCOPFva_diff: voltage angle deviation constraints\neqrefeqSOCOPFpg_bounds-eqrefeqSOCOPFqg_bounds: active/reactive generation limits\neqrefeqSOCOPFwm_bounds: bounds on squared voltage magnitude\neqrefeqSOCOPFwr_bounds-eqrefeqSOCOPFwi_bounds: bounds on voltage product variables\neqrefeqSOCOPFpf_bounds-eqrefeqSOCOPFqt_bounds: power flow bounds, derived from thermal limits","category":"page"},{"location":"opf/socwr/","page":"SOC-OPF","title":"SOC-OPF","text":"info: Info\nAlthough power flow variable boundseqrefeqSOCOPFpf_bounds-eqrefeqSOCOPFqt_bounds are redundant with thermal limits eqrefeqSOCOPFsm_f-eqrefeqSOCOPFsm_t,  their inclusion improves the performance of interior-point solvers like Ipopt.","category":"page"},{"location":"opf/socwr/","page":"SOC-OPF","title":"SOC-OPF","text":"tip: Tip\nWhen using the SOCOPF formulation, all convex quadratic are passed to the solver in conic form. To use quadratic form, e.g., when using a solver that doesn't support conic constraints, use SOCOPFQuad.warning: Warning\nThe SOCOPFQuad formulation does not support conic duality.","category":"page"},{"location":"opf/socwr/#Data-format","page":"SOC-OPF","title":"Data format","text":"","category":"section"},{"location":"opf/socwr/#Primal-solution","page":"SOC-OPF","title":"Primal solution","text":"","category":"section"},{"location":"opf/socwr/","page":"SOC-OPF","title":"SOC-OPF","text":"Variable Data Size Description\nmathbfw w N Squared nodal voltage magnitude\nPG pg G Active power generation\nQG qg G Reactive power generation\nwr wr E Voltage product variable (real part)\nwi wi E Voltage product variable (imaginary part)\nPF pf E Active power flow (from)\nPT pt E Active power flow (to)\nQF qf E Reactive power flow (from)\nQT qt E Reactive power flow (to)","category":"page"},{"location":"opf/socwr/#Dual-solution","page":"SOC-OPF","title":"Dual solution","text":"","category":"section"},{"location":"opf/socwr/","page":"SOC-OPF","title":"SOC-OPF","text":"Constraint Data Size\neqrefeqSOCOPFkcl_p kcl_p N\neqrefeqSOCOPFkcl_q kcl_q N\neqrefeqSOCOPFohm_pf ohm_pf E\neqrefeqSOCOPFohm_qf ohm_qf E\neqrefeqSOCOPFohm_pt ohm_pt E\neqrefeqSOCOPFohm_qt ohm_qt E\neqrefeqSOCOPFjabr jabr E times 4\neqrefeqSOCOPFsm_f sm_fr E times 3\neqrefeqSOCOPFsm_t sm_to E times 3\neqrefeqSOCOPFva_diff va_diff E\neqrefeqSOCOPFpg_bounds pg G\neqrefeqSOCOPFqg_bounds qg G\neqrefeqSOCOPFwm_bounds w N\neqrefeqSOCOPFwr_bounds wr E\neqrefeqSOCOPFwi_bounds wi E\neqrefeqSOCOPFpf_bounds pf E\neqrefeqSOCOPFqf_bounds qf E\neqrefeqSOCOPFpt_bounds pt E\neqrefeqSOCOPFqt_bounds qt E","category":"page"},{"location":"opf/notations/#Notations","page":"Notations","title":"Notations","text":"","category":"section"},{"location":"opf/notations/#Input-parameters","page":"Notations","title":"Input parameters","text":"","category":"section"},{"location":"opf/notations/","page":"Notations","title":"Notations","text":"Sets:","category":"page"},{"location":"opf/notations/","page":"Notations","title":"Notations","text":"mathcalN = 1  N: Set of buses\nmathcalE = 1  E: Set of branches\nmathcalE^+_i: Set of branches leaving bus i in mathcalN\nmathcalE^-_i: Set of branches entering bus i in mathcalN\nmathcalG = 1  G: Set of generators\nmathcalG_i = 1  G_i: Set of generators at bus i in mathcalN\nmathcalL = 1  L: Set of loads at bus i in mathcalN\nmathcalS = 1  S: Set of shunts\nmathcalS = 1  S_i: Set of shunts at bus i in mathcalN.","category":"page"},{"location":"opf/notations/","page":"Notations","title":"Notations","text":"Network data:","category":"page"},{"location":"opf/notations/","page":"Notations","title":"Notations","text":"g^s_s + mathbfj  b^s_s: complex admittance of shunt s in mathcalS\ng_e + mathbfj  b_e: complex admittance of branch e in mathcalE","category":"page"},{"location":"opf/dcp/#DC-OPF","page":"DC-OPF","title":"DC-OPF","text":"","category":"section"},{"location":"opf/dcp/#Mathematical-Formulation","page":"DC-OPF","title":"Mathematical Formulation","text":"","category":"section"},{"location":"opf/dcp/","page":"DC-OPF","title":"DC-OPF","text":"The DCOPF model considered in PGLearn is presented below.","category":"page"},{"location":"opf/dcp/","page":"DC-OPF","title":"DC-OPF","text":"beginalign\n    min_PG PF VA quad\n        sum_i in NODES sum_j in GENERATORS_i c_j PG_j + c_0 labelmodeldcopfobj \n    textst quad\n     sum_jinGENERATORS_iPG_j - sum_e in mathcalE^+_i  PF_e + sum_e in mathcalE^-_i PF_e\n    = sum_jinLOADS_iPD_j + GS_i \n         forall i in NODES\n    labelmodeldcopfkirchhoff \n     -b_e(VA_i - VA_j) - PF_e = 0\n         forall e = (i j) in EDGES\n    labelmodeldcopfohm \n dvamin_e leq VA_i - VA_j leq dvamax_e\n         forall e = (i j) in EDGES\n    labelmodeldcopfangledifference \n     VA_textref = 0 labelmodeldcopfslackbus \n     pgmin_i leq PG_i leq pgmax_i\n         forall i in GENERATORS\n    labelmodeldcopfpgbound \n     -overlineS_e leq  PF_e leq overlineS_e\n         forall e in EDGES\n    labelmodeldcopfthrmboundfrom\nendalign","category":"page"},{"location":"opf/dcp/#Variables","page":"DC-OPF","title":"Variables","text":"","category":"section"},{"location":"opf/dcp/","page":"DC-OPF","title":"DC-OPF","text":"PG in mathbbR^G: active power dispatch\nPF in mathbbR^E: active power flow \"from\"\nVA in mathbbR^N: nodal voltage angle","category":"page"},{"location":"opf/dcp/#Objective","page":"DC-OPF","title":"Objective","text":"","category":"section"},{"location":"opf/dcp/","page":"DC-OPF","title":"DC-OPF","text":"The objective function eqrefmodeldcopfobj minimizes the cost of active power generation.","category":"page"},{"location":"opf/dcp/","page":"DC-OPF","title":"DC-OPF","text":"todo: Todo\nPGLearn currently supports only linear cost functions. Support for quadratic functions is planned for a later stage; please open an issue if  you would like to request this feature.","category":"page"},{"location":"opf/dcp/#Constraints","page":"DC-OPF","title":"Constraints","text":"","category":"section"},{"location":"opf/dcp/","page":"DC-OPF","title":"DC-OPF","text":"eqrefmodeldcopfkirchhoff: Kirchhoff's current law.\neqrefmodeldcopfohm: Ohm's law expressing power flows as a function of nodal voltages.\neqrefmodeldcopfthrmboundfrom: Thermal limits.\neqrefmodeldcopfangledifference: Voltage angle deviation constraints.\neqrefmodeldcopfslackbus: this constraint fixes the voltage angle of the reference (slack) bus to zero.\neqrefmodeldcopfpgbound: Active generation limits.","category":"page"},{"location":"opf/dcp/#Data-Format","page":"DC-OPF","title":"Data Format","text":"","category":"section"},{"location":"opf/dcp/#Primal-variables","page":"DC-OPF","title":"Primal variables","text":"","category":"section"},{"location":"opf/dcp/","page":"DC-OPF","title":"DC-OPF","text":"Symbol Data Size Description\nPG pg G Active power dispatch\nVA va N Nodal voltage angle\nPF pf E Active power flow","category":"page"},{"location":"opf/dcp/#Dual-variables","page":"DC-OPF","title":"Dual variables","text":"","category":"section"},{"location":"opf/dcp/","page":"DC-OPF","title":"DC-OPF","text":"Associated constraint Data Size\neqrefmodeldcopfslackbus slack_bus 1\neqrefmodeldcopfkirchhoff kcl_p N\neqrefmodeldcopfohm ohm E\neqrefmodeldcopfangledifference va_diff E\neqrefmodeldcopfpgbound pg G\neqrefmodeldcopfthrmboundfrom pf E","category":"page"},{"location":"opf/acp/#AC-OPF","page":"AC-OPF","title":"AC-OPF","text":"","category":"section"},{"location":"opf/acp/#Mathematical-Formulation","page":"AC-OPF","title":"Mathematical Formulation","text":"","category":"section"},{"location":"opf/acp/","page":"AC-OPF","title":"AC-OPF","text":"The ACOPF model considered in PGLearn is presented below.","category":"page"},{"location":"opf/acp/","page":"AC-OPF","title":"AC-OPF","text":"beginalign\n    min_PG QG PF QF PT QT VM VA quad\n     sum_i in NODES sum_j in GENERATORS_i c_j PG_j + c_0 labelmodelacopfobj \n    textst quad quad quad\n     sum_jinGENERATORS_iPG_j - sum_jinLOADS_iPD_j - GS_i VM_i^2 = sum_e in mathcalE^+_i  PF_e + sum_e in mathcalE^-_i PT_e\n         forall i in NODES\n        labelmodelacopfkirchhoffactive \n     sum_jinGENERATORS_iQG_j - sum_jinLOADS_iQD_j + BS_i VM_i^2 = sum_e in mathcalE^+_i QF_e + sum_e in mathcalE^-_i QT_e\n         forall i in NODES\n        labelmodelacopfkirchhoffreactive \n     PF_e = gff_eVM_i^2 + gft_e VM_i VM_j cos(VA_i-VA_j) + bft_e VM_i VM_j sin(VA_i-VA_j)\n         forall e = (ij) in EDGES\n        labelmodelacopfohmactivefrom \n     QF_e = -bff_e VM_i^2 - bft_eVM_i VM_j cos(VA_i-VA_j) + gft_e VM_i VM_j sin(VA_i-VA_j)\n         forall e = (ij) in EDGES\n        labelmodelacopfohmreactivefrom \n     PT_e = gtt_eVM_j^2 + gtf_e VM_i VM_j cos(VA_i-VA_j) - btf_e VM_i VM_j sin(VA_i-VA_j)\n         forall e = (ij) in EDGES\n        labelmodelacopfohmactiveto \n     QT_e = -btt_e VM_j^2 - btf_eVM_i VM_j cos(VA_i-VA_j) - gtf_e VM_i VM_j sin(VA_i-VA_j)\n         forall e = (ij) in EDGES\n        labelmodelacopfohmreactiveto \n     (PF_e)^2 + (QF_e)^2 leq overlineS_e^2\n         forall e in EDGES\n        labelmodelacopfthrmboundfrom \n     (PT_e)^2 + (QT_e)^2 leq overlineS_e^2\n         forall e in EDGES\n        labelmodelacopfthrmboundto \n     dvamin_e leq VA_i - VA_j leq dvamax_e\n         forall e = (ij) in EDGES\n        labelmodelacopfangledifference \n     VA_textref = 0\n        labelmodelacopfslackbus \n     pgmin_i leq PG_i leq pgmax_i\n         forall i in GENERATORS\n        labelmodelacopfpgbound \n     qgmin_i leq QG_i leq qgmax_i\n         forall i in GENERATORS\n        labelmodelacopfqgbound \n     vmmin_i leq VM_i leq vmmax_i\n         forall i in NODES\n        labelmodelacopfvmbound \n     -overlineS_e leq  PF_e leq overlineS_e\n         forall e in EDGES\n        labelmodelacopfpfbound \n     -overlineS_e leq  QF_e leq overlineS_e\n         forall e in EDGES\n        labelmodelacopfqfbound \n     -overlineS_e leq  PT_e leq overlineS_e\n         forall e in EDGES\n        labelmodelacopfptbound \n     -overlineS_e leq  QT_e leq overlineS_e\n         forall e in EDGES\n        labelmodelacopfqtbound\nendalign","category":"page"},{"location":"opf/acp/#Variables","page":"AC-OPF","title":"Variables","text":"","category":"section"},{"location":"opf/acp/","page":"AC-OPF","title":"AC-OPF","text":"VM in mathbbR^N: nodal voltage magnitude\nVA in mathbbR^N: nodal voltage angle\nPG in mathbbR^G: active power dispatch\nQG in mathbbR^G: reactive power dispatch\nPF in mathbbR^E: active power flow \"from\"\nQF in mathbbR^E: reactive power flow \"from\"\nPT in mathbbR^E: active power flow \"to\"\nQT in mathbbR^E: reactive power flow \"to\"","category":"page"},{"location":"opf/acp/#Objective","page":"AC-OPF","title":"Objective","text":"","category":"section"},{"location":"opf/acp/","page":"AC-OPF","title":"AC-OPF","text":"The objective function eqrefmodelacopfobj minimizes the cost of active power generation.","category":"page"},{"location":"opf/acp/","page":"AC-OPF","title":"AC-OPF","text":"todo: Todo\nPGLearn currently supports only linear cost functions. Support for quadratic functions is planned for a later stage; please open an issue if  you would like to request this feature.","category":"page"},{"location":"opf/acp/#Constraints","page":"AC-OPF","title":"Constraints","text":"","category":"section"},{"location":"opf/acp/","page":"AC-OPF","title":"AC-OPF","text":"eqrefmodelacopfkirchhoffactive-eqrefmodelacopfkirchhoffreactive:   active and reactive Kirchhoff's current law.\neqrefmodelacopfohmactivefrom-eqrefmodelacopfohmreactiveto:   Ohm's law expressing power flows as a function of nodal voltages.\neqrefmodelacopfthrmboundfrom-eqrefmodelacopfthrmboundto: Thermal limits\neqrefmodelacopfangledifference: Voltage angle deviation constraints.\neqrefmodelacopfslackbus: this constraint fixes the voltage angle of the    reference (slack) bus to zero.\neqrefmodelacopfpgbound-eqrefmodelacopfqgbound: Active/reactive generation limits\neqrefmodelacopfvmbound: Nodal voltage angle limits\neqrefmodelacopfpfbound-eqrefmodelacopfqtbound: Power flow bounds, derived from thermal limits","category":"page"},{"location":"opf/acp/","page":"AC-OPF","title":"AC-OPF","text":"info: Info\nAlthough power flow variable bounds eqrefmodelacopfpfbound-eqrefmodelacopfqtbound are redundant with thermal limits eqrefmodelacopfthrmboundfrom-eqrefmodelacopfthrmboundto,  their inclusion improves the performance of interior-point solvers like Ipopt.","category":"page"},{"location":"opf/acp/#Data-format","page":"AC-OPF","title":"Data format","text":"","category":"section"},{"location":"opf/acp/#Primal-solution","page":"AC-OPF","title":"Primal solution","text":"","category":"section"},{"location":"opf/acp/","page":"AC-OPF","title":"AC-OPF","text":"Variable Data Size Description\nVM vm N Nodal voltage magnitude\nVA va N Nodal voltage angle\nPG pg G Active power generation\nQG pg G Reactive power generation\nPF pf E Active power flow (from)\nPT pt E Active power flow (to)\nQF qf E Reactive power flow (from)\nQT qt E Reactive power flow (to)","category":"page"},{"location":"opf/acp/#Dual-solution","page":"AC-OPF","title":"Dual solution","text":"","category":"section"},{"location":"opf/acp/","page":"AC-OPF","title":"AC-OPF","text":"Constraint Data Size\neqrefmodelacopfkirchhoffactive kcl_p N\neqrefmodelacopfkirchhoffreactive kcl_q N\neqrefmodelacopfohmactivefrom ohm_pf E\neqrefmodelacopfohmreactivefrom ohm_qf E\neqrefmodelacopfohmactiveto ohm_pt E\neqrefmodelacopfohmreactiveto ohm_qt E\neqrefmodelacopfthrmboundfrom sm_fr E\neqrefmodelacopfthrmboundto sm_to E\neqrefmodelacopfangledifference va_diff E\neqrefmodelacopfslackbus slack_bus N\neqrefmodelacopfpgbound pg G\neqrefmodelacopfqgbound qg G\neqrefmodelacopfvmbound vm N\neqrefmodelacopfpfbound pf E\neqrefmodelacopfqfbound qf E\neqrefmodelacopfptbound pt E\neqrefmodelacopfqtbound qt E","category":"page"},{"location":"lib/public/","page":"Reference","title":"Reference","text":"Modules = [PGLearn]","category":"page"},{"location":"lib/public/#PGLearn.E2ELRReserveScaler","page":"Reference","title":"PGLearn.E2ELRReserveScaler","text":"E2ELRReserveScaler\n\nSamples reserve requirements following the procedure below:\n\nSample a minimum reserve requirement MRR from a uniform distribution U(lb, ub) (mrr_dist).\nCompute the upper bound of reserve requirements for each generator as rmax = α * (pmax - pmin).\nFix the lower bound of reserve requirement per generator to zero.\nFix the reserve cost of each generator to zero.\n\nThe parameter α is a scaling factor that determines each generator's maximum reserve     capacity. It is the factor parameter times the ratio of the largest generator's capacity     to the sum of all generators' dispatchable capacity.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#PGLearn.Glocal","page":"Reference","title":"PGLearn.Glocal","text":"Glocal{G,L}\n\nA glocal distribution with global/local factors α::G and  η::L.\n\nThis distribution represents a random variable of the form ϵ = α×η, where\n\nα is a scalar random variable, with distribution d_α::G\nη is a vector random variable, with distribution d_η::L\nα and η are independent random variables\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#PGLearn.LoadScaler","page":"Reference","title":"PGLearn.LoadScaler","text":"LoadScaler{D}\n\nScales loads with multiplicative noise sampled from d::D.\n\nThe distribution d::D is a 2*L-dimensional distribution. The sampled active (resp reactive) demand for load i is denoted by tildep_i (resp. tildeq_i) and has the form\n\ntildep_i = epsilon_i barp_i quad\ntildeq_i = epsilon_i+L barq_i\n\nwhere barp_i barq_i are the reference active/reactive demand for load i, and epsilon in mathbbR^2L is multiplicative noise sampled from distribution d::D.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#PGLearn.Nminus1StatusSampler","page":"Reference","title":"PGLearn.Nminus1StatusSampler","text":"Nminus1StatusSampler\n\nSamples a branch or generator to be inactive following the procedure below:\n\nWith probability 1/2, decide if a branch or generator is inactive in this instance.\n\nIf a branch is inactive:\n\nIdentify the set of branches which are not bridges. Removing a bridge results in a disconnected network.\nSample a branch to be inactive from the set of non-bridge branches.\nConstruct the status vector to be all ones except for zero at the sampled branch.\n\nIf a generator is inactive:\n\nSample a generator to be inactive.\nConstruct the status vector to be all ones except for zero at the sampled generator.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#PGLearn.OPFData-Tuple{Dict{String, Any}}","page":"Reference","title":"PGLearn.OPFData","text":"OPFData(network::Dict{String,Any})\n\nConvert a PowerModels data dictionary to OPFData structure.\n\nThe PowerModels data dictionary must be in basic format.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PGLearn.ScaledLogNormal-Tuple{Float64, Float64, Vector{Float64}}","page":"Reference","title":"PGLearn.ScaledLogNormal","text":"ScaledLogNormal(l, u, σs)\n\nGenerate a Glocal distribution ϵ = α×η where α~U[l,u] and ηᵢ ~ LogNormal(-σᵢ²/2, σᵢ).\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PGLearn.ScaledUniform-Tuple{Float64, Float64, Vector{Float64}}","page":"Reference","title":"PGLearn.ScaledUniform","text":"ScaledUniform(l, u, σs)\n\nGenerate a Glocal distribution ϵ = α×η where α ~ U[l,u] and ηᵢ ~ U[1-σᵢ, 1+σᵢ].\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PGLearn._dedupe_and_sort_h5!-Tuple{Any}","page":"Reference","title":"PGLearn._dedupe_and_sort_h5!","text":"_dedupe_and_sort_h5!(D)\n\nDe-duplicated and sort dataset D in increasing order of random seeds.\n\nEquivalent to _dedupe_h5!(D); _sort_h5!(D), but more efficient.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PGLearn._dedupe_h5!-Tuple{Any}","page":"Reference","title":"PGLearn._dedupe_h5!","text":"_dedupe_h5!(D)\n\nDe-duplicate points in h5 dataset D, according to their random seed.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PGLearn._get_case_info-Tuple{Any}","page":"Reference","title":"PGLearn._get_case_info","text":"_get_case_info(config)\n\nExtract case file and name from input config.\n\nTo be valid, the input config should include:\n\neither a case_file or pglib_case entry\nif no case_file is provided, pglib_case should be a valid, unique PGLib case name.\n\nThe case name will be set to the generic \"case\" value if none is provided.\n\nwarning: Warning\nif case_file is provided, pglib_case will be ignored. Therefore, users should provide case_name when supplying case_file.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PGLearn._merge_h5-Union{Tuple{Array{Array{T, N}, 1}}, Tuple{N}, Tuple{T}} where {T, N}","page":"Reference","title":"PGLearn._merge_h5","text":"_merge_h5(V::Vector{Array{T,N})\n\nConcatenate a collection of N-dimensional arrays along their last dimension.\n\nThis function is semantically equivalent to cat(V...; dims=ndims(first(V))),     but uses a more efficient, splatting-free, implementation. All elements of V must have the same size in the first N-1 dimensions.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PGLearn._select_h5!-Tuple{Dict, Any}","page":"Reference","title":"PGLearn._select_h5!","text":"_select_h5!(D, p)\n\nSelect data points in D as indicated by p.\n\nD should be a dictionary in h5-compatible format, and p is either a     vector of indices, or a logical vector of the same length as D[\"meta\"][\"seed\"].\n\nIf p is a vector of indices, then all values of p should be integers    between 1 and the number of elements in D\nIf p is a logical vector, then it should have the same length as D[\"meta\"][\"seed\"].   Only datapoints i for which p[i] is true are selected.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PGLearn._sort_h5!-Tuple{Any}","page":"Reference","title":"PGLearn._sort_h5!","text":"_sort_h5!(D)\n\nSort dataset D in increasing order of random seeds.\n\nThe dictionary D should be in h5-compatible format. It is modified in-place.\n\nThe function expects D[\"meta\"][\"seed\"] to exist and be a Vector{Int}.     An error is thrown if such an entry is not found.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PGLearn.bridges-Tuple{PGLearn.OPFData}","page":"Reference","title":"PGLearn.bridges","text":"bridges(data)\n\nIdentify whether each branch is a bridge.\n\nThe input data must be in basic format.\n\nA branch is a bridge if removing it renders the network disconnected. Returns a dictionary res::Dict{String,Bool} such that     res[br] is true if branch br is a bridge, and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PGLearn.build_opf-Tuple{Type{PGLearn.ACOPF}, PGLearn.OPFData, Any}","page":"Reference","title":"PGLearn.build_opf","text":"build_opf(ACOPF, data, optimizer)\n\nBuild an ACOPF model.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PGLearn.build_opf-Tuple{Type{PGLearn.DCOPF}, PGLearn.OPFData, Any}","page":"Reference","title":"PGLearn.build_opf","text":"build_opf(DCOPF, data, optimizer)\n\nBuild a DCOPF model.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PGLearn.build_opf-Tuple{Type{PGLearn.SDPOPF}, PGLearn.OPFData, Any}","page":"Reference","title":"PGLearn.build_opf","text":"build_opf(SDPOPF, data, optimizer)\n\nBuild an SDPOPF model.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PGLearn.build_opf-Union{Tuple{OPF}, Tuple{Type{OPF}, PGLearn.OPFData, Any}} where OPF<:Union{PGLearn.SOCOPF, PGLearn.SOCOPFQuad}","page":"Reference","title":"PGLearn.build_opf","text":"build_opf(SOCOPF, data, optimizer)\n\nBuild an SOCOPF model.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PGLearn.compute_flow!-Tuple{Any, Any, PGLearn.FullPTDF}","page":"Reference","title":"PGLearn.compute_flow!","text":"compute_flow!(pf, pg, Φ::FullPTDF)\n\nCompute power flow pf = Φ*pg given PTDF matrix Φ and nodal injections pg.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PGLearn.compute_flow!-Tuple{Any, Any, PGLearn.LazyPTDF}","page":"Reference","title":"PGLearn.compute_flow!","text":"compute_flow!(pf, pg, Φ::LazyPTDF)\n\nCompute power flow pf = Φ*pg lazily, without forming the PTDF matrix.\n\nNamely, pf is computed as pf = BA * (F \\ pg), where F is an LDLᵀ factorization of AᵀBA.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PGLearn.compute_voltage_phasor_bounds-NTuple{6, Any}","page":"Reference","title":"PGLearn.compute_voltage_phasor_bounds","text":"compute_voltage_phasor_bounds(vfmin, vfmax, vtmin, vtmax, dvamin, dvamax)\n\nCompute lower/upper bounds on wr/wi variables.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PGLearn.convert_float_data-Tuple{Any, Any}","page":"Reference","title":"PGLearn.convert_float_data","text":"convert_float_data(D, F)\n\nConvert all floating-point scalars and arrays to F.\n\nArguments\n\nD: Should be a JSON-serializable dictionary, which generally means that   all keys are String and all values are JSON-compatible.\nF: Must be a subtype of AbstractFloat\n\nReturns\n\nd::Dict{String,Any}: a dictionary with same nested structure as D,   with all floating-point scalars and arrays converted to F.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PGLearn.load_h5","page":"Reference","title":"PGLearn.load_h5","text":"load_h5\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PGLearn.load_json-Tuple{AbstractString}","page":"Reference","title":"PGLearn.load_json","text":"load_json(filename::AbstractString)\n\nLoad JSON data from file filename.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PGLearn.ptdf_row-Tuple{PGLearn.FullPTDF, Int64}","page":"Reference","title":"PGLearn.ptdf_row","text":"ptdf_row(Φ::FullPTDF, e::Int)\n\nReturn the e-th row of PTDF matrix Φ.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PGLearn.ptdf_row-Tuple{PGLearn.LazyPTDF, Int64}","page":"Reference","title":"PGLearn.ptdf_row","text":"ptdf_row(Φ::LazyPTDF, e::Int)\n\nReturn the e-th row of (lazy) PTDF matrix Φ.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PGLearn.save_h5-Tuple{AbstractString, Any}","page":"Reference","title":"PGLearn.save_h5","text":"save_h5(filename, D; warn=true)\n\nSaves dictionary D to HDF5 file filename.\n\nArguments\n\nfilename::AbstractString: Path to the HDF5 file; must be a valid path.\nD: Dictionary to save to the file.    All keys in D must be of String type, and it must be HDF5-compatible.   Additional restrictions are enforced on the values of D, see below.\nwarn::Bool=true: Whether to raise a warning when converting numerical data.\n\nwarning: Warning\nOnly the following types are supported:String\n(un)signed integers up to 64-bit precision\nFloat32 and Float64\nComplex versions of the above numeric types\nDense Arrays of the the above scalar typesNumerical data whose type is not listed above will be converted to Float64,   which may incur a loss of precision. A warning will be displayed if this happens unless warn is set to false. If conversion to Float64 is not possible, an error is thrown.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PGLearn.save_json-Tuple{AbstractString, Any}","page":"Reference","title":"PGLearn.save_json","text":"save_json(filename::AbstractString, data; indent)\n\nSave data into JSON file filename. The following formats are supported:\n\nuncompressed JSON .json\nGzip-compressed JSON .json.gz\nBzip2-compressed JSON .json.bz2\n\nIf the file extension does not match one of the above, an error is thrown.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#PGLearn.tensorize-Union{Tuple{Vector{T}}, Tuple{T}} where T","page":"Reference","title":"PGLearn.tensorize","text":"tensorize(V)\n\nConcatenate elements of V into a higher-dimensional tensor.\n\nSimilar to Base.stack, with one major difference: if V is a vector of scalars,     the result is a 2D array M whose last dimension is length(V),     and such that M[:, i] == V[i].\n\nThis function is only defined for Vector{T} and Vector{Array{T,N}} inputs,     to avoid any unexpected behavior of Base.stack.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#Random.rand!-Tuple{Random.AbstractRNG, SimpleOPFSampler, PGLearn.OPFData}","page":"Reference","title":"Random.rand!","text":"rand!(rng::AbstractRNG, s::AbstractOPFSampler, data::Dict)\n\nSample one new OPF instance and modify data in-place.\n\ndata must be a Dict in PowerModels format, representing the same network     (i.e., same grid components with same indexing) as the one used to create s.\n\n\n\n\n\n","category":"method"},{"location":"#PGLearn.jl","page":"Home","title":"PGLearn.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for PGLearn.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"warning: Warning\nThis documentation is a work in progress. Please open an issue if content is missing / erroneous","category":"page"},{"location":"io/","page":"I/O utilities","title":"I/O utilities","text":"PGLearn provides utilities to save/load files in the HDF5 and JSON formats.","category":"page"},{"location":"io/#HDF5","page":"I/O utilities","title":"HDF5","text":"","category":"section"},{"location":"io/","page":"I/O utilities","title":"I/O utilities","text":"To load HDF5 files, use the load_h5, which is the same as HDF5.h5read.","category":"page"},{"location":"io/","page":"I/O utilities","title":"I/O utilities","text":"h = load_h5(\"test_file.h5\", \"/\")  # load all HDF5 file","category":"page"},{"location":"io/","page":"I/O utilities","title":"I/O utilities","text":"To save HDF5 files to disk, use the save_h5 function. All keys of the dictionary (and sub-dictionaries) must be Strings.","category":"page"},{"location":"io/","page":"I/O utilities","title":"I/O utilities","text":"save_h5(\"myfile.h5\", d)","category":"page"},{"location":"io/","page":"I/O utilities","title":"I/O utilities","text":"warning: Warning\nWhen exporting data to an HDF5 file, only the following data types are supported:String\nNumber types supported by HDF5.jl\nArrays of thoseNumerical data in an unsupported type will be converted to Float64, when possible.","category":"page"},{"location":"io/#JSON","page":"I/O utilities","title":"JSON","text":"","category":"section"},{"location":"io/","page":"I/O utilities","title":"I/O utilities","text":"warning: Warning\nOnly .json extensions are supported","category":"page"},{"location":"io/","page":"I/O utilities","title":"I/O utilities","text":"Use the load_json and save_json functions to load/save data to/from JSON files.","category":"page"},{"location":"io/","page":"I/O utilities","title":"I/O utilities","text":"using PGLearn\n\n# Load a dictionary from a JSON file\nd = load_json(\"my_json_file.json\")\n\n# Save a dictionary to a JSON file\nsave_json(\"my_new_jsonfile.json\", d)\nsave_json(\"my_pretty_jsonfile.json\", d, indent=2)  # prettier formatting","category":"page"},{"location":"io/","page":"I/O utilities","title":"I/O utilities","text":"Compressed JSON files (.json.gz and .json.bz2) are supported automatically","category":"page"},{"location":"io/","page":"I/O utilities","title":"I/O utilities","text":"# Load a dictionary from a compressed JSON file\nd = load_json(\"my_json_file.json.gz\")\nd = load_json(\"my_json_file.json.bz2\")\n\n# Save a dictionary to a compressed JSON file\nsave_json(\"my_new_jsonfile.json.gz\", d)\nsave_json(\"my_new_jsonfile.json.bz2\", d)","category":"page"},{"location":"opf/sdpwrm/#SDP-OPF","page":"SDP-OPF","title":"SDP-OPF","text":"","category":"section"},{"location":"opf/sdpwrm/","page":"SDP-OPF","title":"SDP-OPF","text":"The SDP-OPF model considered in PGLearn is presented below.","category":"page"},{"location":"opf/sdpwrm/#Definitions","page":"SDP-OPF","title":"Definitions","text":"","category":"section"},{"location":"opf/sdpwrm/","page":"SDP-OPF","title":"SDP-OPF","text":"Let im be the imaginary unit. Let cdot^* be the complex conjugate operator.","category":"page"},{"location":"opf/sdpwrm/","page":"SDP-OPF","title":"SDP-OPF","text":"The second order cone of order n is defined as","category":"page"},{"location":"opf/sdpwrm/","page":"SDP-OPF","title":"SDP-OPF","text":"mathcalQ^n = left\n    x in mathbbR^n   \n middle \n    x_1 geq sqrtx_2^2 +  + x_n^2\nright","category":"page"},{"location":"opf/sdpwrm/","page":"SDP-OPF","title":"SDP-OPF","text":"The set of n times n symmetric matrices is","category":"page"},{"location":"opf/sdpwrm/","page":"SDP-OPF","title":"SDP-OPF","text":"symmat^n = left\n    X in mathbbR^n times n\n middle \n    X = X^top\nright","category":"page"},{"location":"opf/sdpwrm/","page":"SDP-OPF","title":"SDP-OPF","text":"The set of n times n skew-symmetric matrices is","category":"page"},{"location":"opf/sdpwrm/","page":"SDP-OPF","title":"SDP-OPF","text":"skewmat^n = left\n    X in mathbbR^n times n\n middle \n    X = -X^top\nright","category":"page"},{"location":"opf/sdpwrm/","page":"SDP-OPF","title":"SDP-OPF","text":"The real positive semidefinite cone of order n is defined as","category":"page"},{"location":"opf/sdpwrm/","page":"SDP-OPF","title":"SDP-OPF","text":"psdsymmat^n = left\n    X in symmat^n\n middle \n    X succeq 0\nright","category":"page"},{"location":"opf/sdpwrm/","page":"SDP-OPF","title":"SDP-OPF","text":"which is the set of positive semidefinite n times n symmetric matrices in the real space.","category":"page"},{"location":"opf/sdpwrm/","page":"SDP-OPF","title":"SDP-OPF","text":"A complex square matrix is Hermitian if it is equal to its conjugate transpose. The set of n times n Hermitian matrices is","category":"page"},{"location":"opf/sdpwrm/","page":"SDP-OPF","title":"SDP-OPF","text":"hermat^n = left\n    X in mathbbC^n times n\n middle \n    X = X^H\nright","category":"page"},{"location":"opf/sdpwrm/","page":"SDP-OPF","title":"SDP-OPF","text":"Note that the diagonal entries of a Hermitian matrix are real. The complex positive semidefinite cone of order n is defined as","category":"page"},{"location":"opf/sdpwrm/","page":"SDP-OPF","title":"SDP-OPF","text":"psdhermat^n = left\n    X in hermat^n\n middle \n    X succeq 0\nright","category":"page"},{"location":"opf/sdpwrm/","page":"SDP-OPF","title":"SDP-OPF","text":"which is the set of positive semidefinite n times n Hermitian matrices in the complex space.","category":"page"},{"location":"opf/sdpwrm/#Mathematical-formulation","page":"SDP-OPF","title":"Mathematical formulation","text":"","category":"section"},{"location":"opf/sdpwrm/","page":"SDP-OPF","title":"SDP-OPF","text":"The SDP-OPF formulation in PGLearn is obtained through the change of variable Wsdp = V V^*; i.e., Wsdp_ij = V_i V_j^*. This change allows formulating AC-OPF so that constraints involving Wsdp are linear in Wsdp. It is known that Wsdp = V V^* for some V if and only if Wsdp in psdhermat^N and rank(Wsdp) = 1. By relaxing the rank constraint, a complex semidefinite program (SDP) relaxation of AC-OPF is obtained, where a positive semidefinite constraint requires Wsdp in psdhermat^N.","category":"page"},{"location":"opf/sdpwrm/","page":"SDP-OPF","title":"SDP-OPF","text":"The complex SDP can be converted into a real formulation. Define Wrsdp in symmat^N and Wisdp in skewmat^N. Then, it is known that","category":"page"},{"location":"opf/sdpwrm/","page":"SDP-OPF","title":"SDP-OPF","text":"beginpmatrix\n    Wrsdp  Wisdp \n    -Wisdp  Wrsdp\nendpmatrix = beginpmatrix\n    Wrsdp  Wisdp \n    Wisdp^top  Wrsdp\nendpmatrix in symmat^2N","category":"page"},{"location":"opf/sdpwrm/","page":"SDP-OPF","title":"SDP-OPF","text":"is positive semidefinite if and only if Wsdp = Wrsdp + im Wisdp in hermat^N also is positive semidefinite in the complex space. Note that, by definition, diag(Wsdp) = diag(Wrsdp).","category":"page"},{"location":"opf/sdpwrm/","page":"SDP-OPF","title":"SDP-OPF","text":"The resulting SDP-OPF model in the real space is presented below.","category":"page"},{"location":"opf/sdpwrm/","page":"SDP-OPF","title":"SDP-OPF","text":"beginalign\n    min quad\n     labeleqSDPOPFobjective\n        sum_i in NODES sum_j in GENERATORS_i c_j PG_j + c_0\n        \n    textrmst quad\n     labeleqSDPOPFkcl_p\n        sum_j in GENERATORS_i PG_j\n        - sum_e in EDGES^+_i PF_e\n        - sum_e in EDGES^-_i PT_e\n        - GS_i Wrsdp_ii\n        = sum_jinLOADS_i PD_j\n         forall i  in NODES\n          lambda^p\n        \n     labeleqSDPOPFkcl_q\n        sum_g in mathcalG_i QG_g\n        - sum_e in EDGES^+_i QF_e\n        - sum_e in EDGES^-_i QT_e\n        + BS_i Wrsdp_ii\n        = sum_jinLOADS_i QD_j\n         forall i  in NODES\n          lambda^q\n        \n     Ohms law\n     labeleqSDPOPFohm_pf\n        gff_e Wrsdp_ii\n        + gft_e Wrsdp_e\n        + bft_e Wisdp_e\n        - PF_e = 0\n         forall e = (ij)  in EDGES\n          lambdaPf\n        \n     labeleqSDPOPFohm_qf\n        -bff_e Wrsdp_ii\n        - bft_e Wrsdp_e\n        + gft_e Wisdp_e\n        - QF_e\n        =0\n         forall e = (i j)  in EDGES\n          lambdaQf\n        \n     labeleqSDPOPFohm_pt\n        gtt_e Wrsdp_jj\n        + gtf_e Wrsdp_e\n        - btf_e Wisdp_e\n        - PT_e\n        = 0\n         forall e = (i j)  in EDGES\n          lambdaPt\n        \n     labeleqSDPOPFohm_qt\n        -btt_e Wrsdp_jj\n        - btf_e Wrsdp_e\n        - gtf_e Wisdp_e\n        - QT_e\n        =0 \n         forall e = (i j)  in EDGES\n          lambdaQt\n          \n     Thermal limits\n     labeleqSDPOPFsm_f\n        (bars_e PF_e QF_e) in mathcalQ^3\n         forall e  in EDGES \n          nuThermalfr\n        \n     labeleqSDPOPFsm_t\n        (bars_e PT_e QT_e) in mathcalQ^3\n         forall e  in EDGES \n          nuThermalto\n        \n     Voltage angle deviation\n     labeleqSDPOPFva_diff\n        tan(dvamin_e) Wrsdp_e leq Wisdp_e leq tan(dvamax_e) Wrsdp_e \n         forall e  in EDGES\n          muAngleDiff\n        \n     Variable bounds\n      labeleqSDPOPFpg_bounds\n        pgmin_i leq PG_i leq pgmax_i\n         forall i  in GENERATORS\n          muPg\n        \n     labeleqSDPOPFqg_bounds\n        qgmin_i leq QG_i leq qgmax_i \n         forall i  in GENERATORS\n          muQg\n        \n     labeleqSDPOPFwm_bounds\n        vmmin_i^2 leq Wrsdp_ii leq vmmax_i^2 \n         forall i  in NODES\n          muWm\n        \n     labeleqSDPOPFpf_bounds\n        -overlineS_e leq PF_e leq overlineS_e\n         forall e  in EDGES\n          mu^pf\n        \n     labeleqSDPOPFqf_bounds\n        -overlineS_e leq QF_e leq overlineS_e\n         forall e  in EDGES\n          mu^qf\n        \n     labeleqSDPOPFpt_bounds\n        -overlineS_e leq PT_e leq overlineS_e\n         forall e  in EDGES\n           mu^pt\n        \n     labeleqSDPOPFqt_bounds\n        -overlineS_e leq QT_e leq overlineS_e\n         forall e  in EDGES\n          mu^qt\n        \n     PSD constraint\n     labeleqSDPOPFpsd\n        beginpmatrix\n            Wrsdp  Wisdp \n            -Wisdp  Wrsdp\n        endpmatrix in psdsymmat^2N\n        \n          Ssdp\nendalign","category":"page"},{"location":"opf/sdpwrm/","page":"SDP-OPF","title":"SDP-OPF","text":"info: Info\nIf there are multiple branches e_1 e_2  from bus i to j, then Wrsdp_e_1 Wrsdp_e_2 will all refer to the same Wrsdp_ij entry in the matrix. Similarly for Wisdp.","category":"page"},{"location":"opf/sdpwrm/","page":"SDP-OPF","title":"SDP-OPF","text":"info: Info\nIf branch e in EDGES is connected from bus i to j, then Wisdp_e refers to Wisdp_ij. If instead branch e is connected from bus j to i, then Wisdp_e refers to Wisdp_ji, which by definition is equal to -Wisdp_ij.","category":"page"},{"location":"opf/sdpwrm/","page":"SDP-OPF","title":"SDP-OPF","text":"More details of the model can be found in Qiu, G., Tanneau, M., & Van Hentenryck, P. (2025). Dual Conic Proxy for Semidefinite Relaxation of AC Optimal Power Flow. arXiv preprint arXiv:2502.06978.","category":"page"},{"location":"opf/sdpwrm/#Variables","page":"SDP-OPF","title":"Variables","text":"","category":"section"},{"location":"opf/sdpwrm/","page":"SDP-OPF","title":"SDP-OPF","text":"PG in mathbbR^G: active power dispatch\nQG in mathbbR^G: reactive power dispatch\nWrsdp in symmat^N: real part of voltage product\nWisdp in skewmat^N: imaginary part of voltage product\nPF in mathbbR^E: active power flow \"from\"\nQF in mathbbR^E: reactive power flow \"from\"\nPT in mathbbR^E: active power flow \"to\"\nQT in mathbbR^E: reactive power flow \"to\"","category":"page"},{"location":"opf/sdpwrm/#Objective","page":"SDP-OPF","title":"Objective","text":"","category":"section"},{"location":"opf/sdpwrm/","page":"SDP-OPF","title":"SDP-OPF","text":"The objective function eqrefeqSDPOPFobjective minimizes the cost of active power generation.","category":"page"},{"location":"opf/sdpwrm/","page":"SDP-OPF","title":"SDP-OPF","text":"todo: Todo\nPGLearn currently supports only linear cost functions. Support for quadratic functions is planned for a later stage; please open an issue if  you would like to request this feature.","category":"page"},{"location":"opf/sdpwrm/#Constraints","page":"SDP-OPF","title":"Constraints","text":"","category":"section"},{"location":"opf/sdpwrm/","page":"SDP-OPF","title":"SDP-OPF","text":"eqrefeqSDPOPFkcl_p-eqrefeqSDPOPFkcl_q:   Kirchhoff's current law for active and reactive power\neqrefeqSDPOPFohm_pf-eqrefeqSDPOPFohm_qt:   Ohm's law for active/reactive power flows in from and to directions\neqrefeqSDPOPFsm_f-eqrefeqSDPOPFsm_t: thermal limits\neqrefeqSDPOPFva_diff: voltage angle deviation constraints\neqrefeqSDPOPFpg_bounds-eqrefeqSDPOPFqg_bounds: active/reactive generation limits\neqrefeqSDPOPFwm_bounds: bounds on squared voltage magnitude\neqrefeqSDPOPFpf_bounds-eqrefeqSDPOPFqt_bounds: power flow bounds, derived from thermal limits\neqrefeqSDPOPFpsd: positive semidefinite constraint","category":"page"},{"location":"opf/sdpwrm/","page":"SDP-OPF","title":"SDP-OPF","text":"info: Info\nAlthough power flow variable boundseqrefeqSDPOPFpf_bounds-eqrefeqSDPOPFqt_bounds are redundant with thermal limits eqrefeqSDPOPFsm_f-eqrefeqSDPOPFsm_t,  their inclusion improves the performance of interior-point solvers like Ipopt.","category":"page"},{"location":"opf/sdpwrm/#Data-format","page":"SDP-OPF","title":"Data format","text":"","category":"section"},{"location":"opf/sdpwrm/#Primal-solution","page":"SDP-OPF","title":"Primal solution","text":"","category":"section"},{"location":"opf/sdpwrm/","page":"SDP-OPF","title":"SDP-OPF","text":"Variable Data Size Description\ndiag(Wrsdp) w N Squared nodal voltage magnitude, the diagonal entries of Wrsdp\nPG pg G Active power generation\nQG pg G Reactive power generation\nWrsdp_EDGES wr E Voltage product variable (real part) corresponding to branches\nWisdp_EDGES wi E Voltage product variable (imaginary part) corresponding to branches\nPF pf E Active power flow (from)\nPT pt E Active power flow (to)\nQF qf E Reactive power flow (from)\nQT qt E Reactive power flow (to)","category":"page"},{"location":"opf/sdpwrm/","page":"SDP-OPF","title":"SDP-OPF","text":"Since Wrsdp and Wisdp can be dense, only the off-diagonal entries that correspond to branches are extracted to save space. Other entries only appear in constraints the positive semidefinite constraint eqrefeqSDPOPFpsd and not other constraints. Therefore, values of these entries can be obtained by solving a positive semidefinite matrix completion problem to recover a full feasible matrix.","category":"page"},{"location":"opf/sdpwrm/","page":"SDP-OPF","title":"SDP-OPF","text":"info: Info\nIf there are multiple parallel branches e_1 e_2  from bus i to j, the same entries Wrsdp_ij and Wisdp_ij are extracted for each of the branches.","category":"page"},{"location":"opf/sdpwrm/#Dual-solution","page":"SDP-OPF","title":"Dual solution","text":"","category":"section"},{"location":"opf/sdpwrm/","page":"SDP-OPF","title":"SDP-OPF","text":"Constraint Data Size\neqrefeqSDPOPFkcl_p kcl_p N\neqrefeqSDPOPFkcl_q kcl_q N\neqrefeqSDPOPFohm_pf ohm_pf E\neqrefeqSDPOPFohm_qf ohm_qf E\neqrefeqSDPOPFohm_pt ohm_pt E\neqrefeqSDPOPFohm_qt ohm_qt E\neqrefeqSDPOPFsm_f sm_fr E times 3\neqrefeqSDPOPFsm_t sm_to E times 3\neqrefeqSDPOPFva_diff va_diff E\neqrefeqSDPOPFpg_bounds pg G\neqrefeqSDPOPFqg_bounds qg G\neqrefeqSDPOPFwm_bounds w N\neqrefeqSDPOPFpf_bounds pf E\neqrefeqSDPOPFqf_bounds qf E\neqrefeqSDPOPFpt_bounds pt E\neqrefeqSDPOPFqt_bounds qt E\neqrefeqSDPOPFpsd s, sr, si N, E, E","category":"page"},{"location":"opf/sdpwrm/","page":"SDP-OPF","title":"SDP-OPF","text":"The dual variable corresponding to the positive semidefinite constraint eqrefeqSDPOPFpsd of the real SDP-OPF is Ssdp which is constrained to be in psdsymmat^2N.","category":"page"},{"location":"opf/sdpwrm/","page":"SDP-OPF","title":"SDP-OPF","text":"By deriving the dual of the complex SDP formulation, it can be shown that any feasible Ssdp in the real formulation has the same 4-block structure as the primal matrix, and each block has a sparsity structure corresponding to EDGES. Without considering the complex formulation, the dual problem of the real formulation also implies a transformation to obtain such a feasible sparse 4-block matrix from any feasible Ssdp easily. Therefore, without loss of generality,","category":"page"},{"location":"opf/sdpwrm/","page":"SDP-OPF","title":"SDP-OPF","text":"Ssdp =\nbeginpmatrix\n    Srsdp  Sisdp \n    -Sisdp  Srsdp\nendpmatrix","category":"page"},{"location":"opf/sdpwrm/","page":"SDP-OPF","title":"SDP-OPF","text":"where the off-diagonal entries of Srsdp in symmat^N and Sisdp in skewmat^N that don't correspond to any branch are 0.","category":"page"},{"location":"opf/sdpwrm/","page":"SDP-OPF","title":"SDP-OPF","text":"info: Info\nCurrently, there is no necessity to compute the aforementioned transformation, since interior point solvers and splitting cone solvers are observed to produce Ssdp with the sparse 4-block structure when solving SDP-OPF, even though sparsity is not explicitly exploited.","category":"page"},{"location":"opf/sdpwrm/","page":"SDP-OPF","title":"SDP-OPF","text":"s, sr and si are the diagonal entries of Srsdp, the off-diagonal entries of Srsdp that correspond to branches, and the off-diagonal entries of Sisdp that correspond to branches, respectively. Unlike in the primal case, these values are sufficient to directly reconstruct the original Ssdp.","category":"page"}]
}
